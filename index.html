<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dot Grid Illustrations</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            max-height: 85vh;
            overflow-y: auto;
            min-width: 220px;
        }
        
        .controls label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
            flex: 1;
        }
        
        .controls input[type="range"] {
            flex: 1;
            min-width: 80px;
        }
        
        .controls input[type="number"] {
            width: 50px;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            color: white;
            font-size: 11px;
        }
        
        .controls select {
            margin-left: 10px;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            color: white;
            font-size: 11px;
        }
        
        .controls .section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .controls .section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            color: #4CAF50;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        /* Custom scrollbar */
        .controls::-webkit-scrollbar {
            width: 6px;
        }
        
        .controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .controls::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .rotation-btn {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: white;
            padding: 6px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        
        .rotation-btn:hover {
            background: rgba(76, 175, 80, 0.4);
            border-color: rgba(76, 175, 80, 0.8);
        }
        
        .rotation-btn:active {
            background: rgba(76, 175, 80, 0.6);
        }
        
        .rotation-btn:disabled {
            background: rgba(100, 100, 100, 0.2);
            border-color: rgba(100, 100, 100, 0.3);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="section">
            <div class="section-title">Wave Properties</div>
            <label>Wave Height:
                <div class="control-group">
                    <input type="range" id="amplitude" min="0.1" max="15" step="0.1" value="2">
                    <input type="number" id="amplitudeNum" min="0.1" max="15" step="0.1" value="2">
                </div>
            </label>
            <label>Wave Speed:
                <div class="control-group">
                    <input type="range" id="speed" min="0.1" max="3" step="0.1" value="0.8">
                    <input type="number" id="speedNum" min="0.1" max="3" step="0.1" value="0.8">
                </div>
            </label>
            <label>Wave Scale:
                <div class="control-group">
                    <input type="range" id="waveScale" min="0.2" max="5" step="0.1" value="1">
                    <input type="number" id="waveScaleNum" min="0.2" max="5" step="0.1" value="1">
                </div>
            </label>
        </div>
        
        <div class="section">
            <div class="section-title">Grid Settings</div>
            <label>Grid Density:
                <div class="control-group">
                    <input type="range" id="gridSize" min="30" max="80" step="5" value="50">
                    <input type="number" id="gridSizeNum" min="30" max="80" step="5" value="50">
                </div>
            </label>
            <label>Dot Size:
                <div class="control-group">
                    <input type="range" id="dotSize" min="0.5" max="10" step="0.1" value="4">
                    <input type="number" id="dotSizeNum" min="0.5" max="10" step="0.1" value="4">
                </div>
            </label>
        </div>
        
        <div class="section">
            <div class="section-title">Displacement Mode</div>
            <label>Type: 
                <select id="displacementType">
                    <option value="wave">Sine Waves</option>
                    <option value="perlin">Perlin Noise</option>
                    <option value="quantizedWave">Quantized Waves</option>
                    <option value="quantizedPerlin">Quantized Perlin</option>
                    <option value="radar">Radar Circles</option>
                    <option value="grid">Grid Pattern</option>
                    <option value="frequencyBands">Frequency Bands</option>
                    <option value="spiral">Spiral Wave</option>
                    <option value="checkerboard">Checkerboard</option>
                    <option value="ripples">Multi Ripples</option>
                    <option value="fractal">Fractal Noise</option>
                    <option value="diagonal">Diagonal Waves</option>
                </select>
            </label>
            <label>Quantization Steps:
                <div class="control-group">
                    <input type="range" id="quantSteps" min="2" max="20" step="1" value="8">
                    <input type="number" id="quantStepsNum" min="2" max="20" step="1" value="8">
                </div>
            </label>
        </div>
        
        <div class="section">
            <div class="section-title">Camera</div>
            <label>Zoom:
                <div class="control-group">
                    <input type="range" id="zoom" min="5" max="25" step="1" value="15">
                    <input type="number" id="zoomNum" min="5" max="25" step="1" value="15">
                </div>
            </label>
        </div>
        
        <div class="section">
            <div class="section-title">Auto Rotation</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                <button class="rotation-btn" onclick="rotateCamera('x', 90)">X +90°</button>
                <button class="rotation-btn" onclick="rotateCamera('x', -90)">X -90°</button>
                <button class="rotation-btn" onclick="rotateCamera('y', 90)">Y +90°</button>
                <button class="rotation-btn" onclick="rotateCamera('y', -90)">Y -90°</button>
                <button class="rotation-btn" onclick="rotateCamera('z', 90)">Z +90°</button>
                <button class="rotation-btn" onclick="rotateCamera('z', -90)">Z -90°</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
                <button class="rotation-btn" onclick="rotateCamera('x', 180)">X 180°</button>
                <button class="rotation-btn" onclick="rotateCamera('y', 180)">Y 180°</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr; gap: 8px; margin-bottom: 10px;">
                <button class="rotation-btn" onclick="rotateCamera('orbit', 360)">Orbit 360°</button>
                <button class="rotation-btn" onclick="resetCamera()">Reset View</button>
            </div>
            <label>Rotation Speed:
                <div class="control-group">
                    <input type="range" id="rotationSpeed" min="0.5" max="3" step="0.1" value="1.5">
                    <input type="number" id="rotationSpeedNum" min="0.5" max="3" step="0.1" value="1.5">
                </div>
            </label>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Simple mouse controls for orthographic camera
        class SimpleControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.enabled = true;
                
                this.rotationX = -0.3;
                this.rotationY = 0;
                this.isDragging = false;
                this.previousMousePosition = { x: 0, y: 0 };
                
                // Animation properties
                this.isAnimating = false;
                this.animationStart = 0;
                this.animationDuration = 1000; // 1 second default
                this.startRotation = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.animationType = 'rotate';
                
                this.init();
                this.updateCamera();
            }
            
            init() {
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this), false);
                this.domElement.addEventListener('mousemove', this.onMouseMove.bind(this), false);
                this.domElement.addEventListener('mouseup', this.onMouseUp.bind(this), false);
                this.domElement.addEventListener('wheel', this.onWheel.bind(this), false);
            }
            
            onMouseDown(event) {
                if (!this.enabled || this.isAnimating) return;
                this.isDragging = true;
                this.previousMousePosition = { x: event.clientX, y: event.clientY };
            }
            
            onMouseMove(event) {
                if (!this.enabled || !this.isDragging || this.isAnimating) return;
                
                const deltaX = event.clientX - this.previousMousePosition.x;
                const deltaY = event.clientY - this.previousMousePosition.y;
                
                this.rotationY += deltaX * 0.005;
                this.rotationX += deltaY * 0.005;
                
                // Limit rotation
                this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                
                this.previousMousePosition = { x: event.clientX, y: event.clientY };
                this.updateCamera();
            }
            
            onMouseUp() {
                this.isDragging = false;
            }
            
            onWheel(event) {
                if (!this.enabled || this.isAnimating) return;
                event.preventDefault();
                
                const zoomSlider = document.getElementById('zoom');
                const zoomNum = document.getElementById('zoomNum');
                let currentZoom = parseFloat(zoomSlider.value);
                currentZoom += event.deltaY > 0 ? 1 : -1;
                currentZoom = Math.max(5, Math.min(25, currentZoom));
                zoomSlider.value = currentZoom;
                zoomNum.value = currentZoom;
                
                this.updateZoom(currentZoom);
            }
            
            updateCamera() {
                const distance = 20;
                this.camera.position.x = Math.sin(this.rotationY) * Math.cos(this.rotationX) * distance;
                this.camera.position.y = Math.sin(this.rotationX) * distance;
                this.camera.position.z = Math.cos(this.rotationY) * Math.cos(this.rotationX) * distance;
                this.camera.lookAt(0, 0, 0);
            }
            
            updateZoom(zoom) {
                this.camera.left = -zoom;
                this.camera.right = zoom;
                this.camera.top = zoom;
                this.camera.bottom = -zoom;
                this.camera.updateProjectionMatrix();
            }
            
            // Smooth rotation animation
            animateRotation(axis, degrees) {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                this.animationStart = Date.now();
                this.startRotation = { x: this.rotationX, y: this.rotationY };
                
                const radians = (degrees * Math.PI) / 180;
                
                // Calculate target rotation based on axis
                switch (axis) {
                    case 'x':
                        this.targetRotation = {
                            x: this.rotationX + radians,
                            y: this.rotationY
                        };
                        break;
                    case 'y':
                        this.targetRotation = {
                            x: this.rotationX,
                            y: this.rotationY + radians
                        };
                        break;
                    case 'z':
                        // Z rotation affects both X and Y to create a roll effect
                        this.targetRotation = {
                            x: this.rotationX + radians * 0.3,
                            y: this.rotationY + radians
                        };
                        break;
                    case 'orbit':
                        this.targetRotation = {
                            x: this.rotationX,
                            y: this.rotationY + radians
                        };
                        this.animationType = 'orbit';
                        break;
                }
                
                // Clamp target rotation
                this.targetRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.targetRotation.x));
                
                // Set animation duration based on rotation speed
                const rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
                this.animationDuration = (Math.abs(degrees) / 90) * (1000 / rotationSpeed);
                
                this.updateButtons(true);
            }
            
            // Update animation frame
            updateAnimation() {
                if (!this.isAnimating) return;
                
                const elapsed = Date.now() - this.animationStart;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Interpolate rotation
                this.rotationX = this.startRotation.x + (this.targetRotation.x - this.startRotation.x) * easeProgress;
                this.rotationY = this.startRotation.y + (this.targetRotation.y - this.startRotation.y) * easeProgress;
                
                this.updateCamera();
                
                if (progress >= 1) {
                    this.isAnimating = false;
                    this.animationType = 'rotate';
                    this.updateButtons(false);
                }
            }
            
            // Reset to default view
            resetView() {
                if (this.isAnimating) return;
                
                this.isAnimating = true;
                this.animationStart = Date.now();
                this.startRotation = { x: this.rotationX, y: this.rotationY };
                this.targetRotation = { x: -0.3, y: 0 };
                
                const rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
                this.animationDuration = 1000 / rotationSpeed;
                
                this.updateButtons(true);
            }
            
            // Update button states
            updateButtons(disabled) {
                const buttons = document.querySelectorAll('.rotation-btn');
                buttons.forEach(btn => btn.disabled = disabled);
            }
        }

        // Simplified circle texture
        function createCircleTexture() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 32;
            canvas.height = 32;

            const center = 16;
            const radius = 14;

            context.clearRect(0, 0, 32, 32);
            
            // Solid white circle
            context.fillStyle = 'white';
            context.beginPath();
            context.arc(center, center, radius, 0, 2 * Math.PI);
            context.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // Scene setup with orthographic camera
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-15 * aspect, 15 * aspect, 15, -15, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);

        // Variables
        let gridSize = 50;
        let spacing = 0.5;
        let amplitude = 2;
        let speed = 0.8;
        let waveScale = 1;
        let quantSteps = 8;
        let dotSize = 4;
        let time = 0;
        let points = [];
        let geometry, material, pointCloud;
        let displacementType = 'wave';

        const circleTexture = createCircleTexture();

        // Perlin noise implementation
        class PerlinNoise {
            constructor() {
                this.permutation = [];
                this.p = [];
                
                // Initialize permutation table
                for (let i = 0; i < 256; i++) {
                    this.permutation[i] = i;
                }
                
                // Shuffle the permutation table
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
                }
                
                // Duplicate the permutation table
                for (let i = 0; i < 512; i++) {
                    this.p[i] = this.permutation[i % 256];
                }
            }
            
            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }
            
            lerp(t, a, b) {
                return a + t * (b - a);
            }
            
            grad(hash, x, y, z) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }
            
            noise(x, y, z) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                const Z = Math.floor(z) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                z -= Math.floor(z);
                
                const u = this.fade(x);
                const v = this.fade(y);
                const w = this.fade(z);
                
                const A = this.p[X] + Y;
                const AA = this.p[A] + Z;
                const AB = this.p[A + 1] + Z;
                const B = this.p[X + 1] + Y;
                const BA = this.p[B] + Z;
                const BB = this.p[B + 1] + Z;
                
                return this.lerp(w,
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA], x, y, z), this.grad(this.p[BA], x - 1, y, z)),
                        this.lerp(u, this.grad(this.p[AB], x, y - 1, z), this.grad(this.p[BB], x - 1, y - 1, z))
                    ),
                    this.lerp(v,
                        this.lerp(u, this.grad(this.p[AA + 1], x, y, z - 1), this.grad(this.p[BA + 1], x - 1, y, z - 1)),
                        this.lerp(u, this.grad(this.p[AB + 1], x, y - 1, z - 1), this.grad(this.p[BB + 1], x - 1, y - 1, z - 1))
                    )
                );
            }
            
            // Octave noise for more natural-looking displacement
            octaveNoise(x, y, z, octaves = 3, persistence = 0.5, lacunarity = 2.0) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    value += this.noise(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                
                return value / maxValue;
            }
        }
        
        // Create Perlin noise instance
        const perlin = new PerlinNoise();

        // Displacement functions
        function simpleWave(x, y, time) {
            const freq1 = 0.15 * waveScale;
            const freq2 = 0.08 * waveScale;
            const timeOffset = time * speed;
            
            const wave1 = Math.sin(x * freq1 + timeOffset) * Math.cos(y * freq1 + timeOffset * 0.7);
            const wave2 = Math.sin(x * freq2 - timeOffset * 0.5) * Math.sin(y * freq2 + timeOffset * 0.3);
            
            return (wave1 + wave2 * 0.5) * amplitude;
        }

        function perlinDisplacement(x, y, time) {
            const freq = 0.02 * waveScale;
            const timeScale = time * speed * 0.1;
            
            return perlin.octaveNoise(x * freq, y * freq, timeScale, 3, 0.5, 2.0) * amplitude * 2;
        }

        // Quantization helper function
        function quantizeValue(value, steps) {
            return Math.round(value * steps) / steps;
        }

        // Quantized displacement functions
        function quantizedWave(x, y, time) {
            const waveValue = simpleWave(x, y, time);
            return quantizeValue(waveValue, quantSteps);
        }

        function quantizedPerlin(x, y, time) {
            const perlinValue = perlinDisplacement(x, y, time);
            return quantizeValue(perlinValue, quantSteps);
        }

        // Technical radar circles pattern
        function radarPattern(x, y, time) {
            const centerX = 0;
            const centerY = 0;
            const distance = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
            const freq = 0.3 * waveScale;
            const timeOffset = time * speed;
            
            const wave = Math.sin(distance * freq - timeOffset);
            return wave * amplitude;
        }

        // Grid pattern - creates a 3D grid of peaks and valleys
        function gridPattern(x, y, time) {
            const freq = 0.4 * waveScale;
            const timeOffset = time * speed;
            
            const gridX = Math.sin(x * freq + timeOffset);
            const gridY = Math.sin(y * freq + timeOffset * 0.7);
            
            return (gridX * gridY) * amplitude;
        }

        // Frequency bands - horizontal bands like an audio visualizer
        function frequencyBands(x, y, time) {
            const bands = 8;
            const bandHeight = 5;
            const freq = 0.2 * waveScale;
            const timeOffset = time * speed;
            
            const bandIndex = Math.floor((y + bandHeight * bands / 2) / bandHeight);
            const bandCenter = (bandIndex * bandHeight) - (bandHeight * bands / 2) + bandHeight / 2;
            const distanceFromCenter = Math.abs(y - bandCenter);
            
            if (distanceFromCenter < bandHeight / 2) {
                const bandPhase = bandIndex * 0.5 + timeOffset;
                const bandAmplitude = Math.sin(x * freq + bandPhase) * (1 - distanceFromCenter / (bandHeight / 2));
                return bandAmplitude * amplitude;
            }
            
            return 0;
        }

        // Spiral wave pattern
        function spiralPattern(x, y, time) {
            const distance = Math.sqrt(x * x + y * y);
            const angle = Math.atan2(y, x);
            const spiralFreq = 0.3 * waveScale;
            const timeOffset = time * speed;
            
            const spiral = Math.sin(distance * spiralFreq - angle * 3 + timeOffset);
            return spiral * amplitude;
        }

        // Checkerboard pattern with animated height
        function checkerboardPattern(x, y, time) {
            const cellSize = 2 / waveScale;
            const timeOffset = time * speed;
            
            const cellX = Math.floor(x / cellSize);
            const cellY = Math.floor(y / cellSize);
            const isEven = (cellX + cellY) % 2 === 0;
            
            const wave = Math.sin(timeOffset * 2);
            return (isEven ? wave : -wave) * amplitude;
        }

        // Multiple ripples from different points
        function multiRipples(x, y, time) {
            const timeOffset = time * speed;
            const freq = 0.4 * waveScale;
            
            // Multiple ripple sources
            const sources = [
                { x: -5, y: -5, phase: 0 },
                { x: 5, y: 5, phase: Math.PI },
                { x: -5, y: 5, phase: Math.PI / 2 },
                { x: 5, y: -5, phase: 3 * Math.PI / 2 }
            ];
            
            let totalWave = 0;
            sources.forEach(source => {
                const distance = Math.sqrt((x - source.x) * (x - source.x) + (y - source.y) * (y - source.y));
                const wave = Math.sin(distance * freq - timeOffset + source.phase);
                totalWave += wave / sources.length;
            });
            
            return totalWave * amplitude;
        }

        // Fractal-like noise pattern
        function fractalPattern(x, y, time) {
            const timeOffset = time * speed * 0.1;
            const baseFreq = 0.05 * waveScale;
            
            let total = 0;
            let amplitude_local = 1;
            let frequency = baseFreq;
            
            for (let i = 0; i < 4; i++) {
                total += perlin.noise(x * frequency, y * frequency, timeOffset) * amplitude_local;
                amplitude_local *= 0.5;
                frequency *= 2;
            }
            
            return total * amplitude;
        }

        // Diagonal wave pattern
        function diagonalWaves(x, y, time) {
            const freq = 0.2 * waveScale;
            const timeOffset = time * speed;
            
            const diagonal1 = Math.sin((x + y) * freq + timeOffset);
            const diagonal2 = Math.sin((x - y) * freq + timeOffset * 0.7);
            
            return (diagonal1 + diagonal2 * 0.5) * amplitude;
        }

        function getDisplacement(x, y, time) {
            switch (displacementType) {
                case 'perlin':
                    return perlinDisplacement(x, y, time);
                case 'quantizedWave':
                    return quantizedWave(x, y, time);
                case 'quantizedPerlin':
                    return quantizedPerlin(x, y, time);
                case 'radar':
                    return radarPattern(x, y, time);
                case 'grid':
                    return gridPattern(x, y, time);
                case 'frequencyBands':
                    return frequencyBands(x, y, time);
                case 'spiral':
                    return spiralPattern(x, y, time);
                case 'checkerboard':
                    return checkerboardPattern(x, y, time);
                case 'ripples':
                    return multiRipples(x, y, time);
                case 'fractal':
                    return fractalPattern(x, y, time);
                case 'diagonal':
                    return diagonalWaves(x, y, time);
                default:
                    return simpleWave(x, y, time);
            }
        }

        function createDotMatrix() {
            if (pointCloud) {
                scene.remove(pointCloud);
                geometry.dispose();
                material.dispose();
            }

            points = [];
            const positions = [];

            for (let x = 0; x < gridSize; x++) {
                for (let y = 0; y < gridSize; y++) {
                    const worldX = (x - gridSize / 2) * spacing;
                    const worldY = (y - gridSize / 2) * spacing;
                    const worldZ = getDisplacement(worldX * 2, worldY * 2, time);

                    positions.push(worldX, worldY, worldZ);
                    points.push({ x: worldX, y: worldY });
                }
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            material = new THREE.PointsMaterial({
                size: dotSize,
                map: circleTexture,
                color: 0xffffff,
                transparent: false,
                sizeAttenuation: false // Keep dots same size regardless of distance
            });

            pointCloud = new THREE.Points(geometry, material);
            scene.add(pointCloud);
        }

        function updateDotMatrix() {
            if (!geometry) return;

            const positions = geometry.attributes.position.array;

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const newZ = getDisplacement(point.x * 2, point.y * 2, time);
                positions[i * 3 + 2] = newZ;
            }

            geometry.attributes.position.needsUpdate = true;
        }

        // Camera setup and controls
        camera.position.set(0, -10, 8);
        camera.lookAt(0, 0, 0);
        
        const controls = new SimpleControls(camera, renderer.domElement);

        // Utility function to create synchronized control pairs
        function createControlPair(sliderId, numberId, callback) {
            const slider = document.getElementById(sliderId);
            const numberInput = document.getElementById(numberId);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                numberInput.value = value;
                callback(value);
            });
            
            numberInput.addEventListener('input', (e) => {
                let value = parseFloat(e.target.value);
                const min = parseFloat(numberInput.min);
                const max = parseFloat(numberInput.max);
                
                // Clamp value to valid range
                if (value < min) value = min;
                if (value > max) value = max;
                
                numberInput.value = value;
                slider.value = value;
                callback(value);
            });
            
            // Handle blur event to ensure valid values
            numberInput.addEventListener('blur', (e) => {
                if (isNaN(parseFloat(e.target.value)) || e.target.value === '') {
                    e.target.value = slider.value;
                }
            });
        }

        // Set up all control pairs
        createControlPair('amplitude', 'amplitudeNum', (value) => {
            amplitude = value;
        });

        createControlPair('speed', 'speedNum', (value) => {
            speed = value;
        });

        createControlPair('waveScale', 'waveScaleNum', (value) => {
            waveScale = value;
        });

        createControlPair('quantSteps', 'quantStepsNum', (value) => {
            quantSteps = value;
        });

        createControlPair('gridSize', 'gridSizeNum', (value) => {
            gridSize = parseInt(value);
            createDotMatrix();
        });

        createControlPair('dotSize', 'dotSizeNum', (value) => {
            dotSize = value;
            if (material) material.size = dotSize;
        });

        createControlPair('zoom', 'zoomNum', (value) => {
            controls.updateZoom(value);
        });

        createControlPair('rotationSpeed', 'rotationSpeedNum', (value) => {
            // Rotation speed is used in the animation system
        });

        // Displacement type selector
        document.getElementById('displacementType').addEventListener('change', (e) => {
            displacementType = e.target.value;
        });

        // Global rotation functions
        window.rotateCamera = function(axis, degrees) {
            controls.animateRotation(axis, degrees);
        };

        window.resetCamera = function() {
            controls.resetView();
        };

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Update camera animation
            controls.updateAnimation();
            
            updateDotMatrix();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            const zoom = parseFloat(document.getElementById('zoom').value);
            
            camera.left = -zoom * aspect;
            camera.right = zoom * aspect;
            camera.top = zoom;
            camera.bottom = -zoom;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        createDotMatrix();
        animate();
    </script>
</body>
</html>
